{"version":3,"names":["CellRenderMask","numCells","_numCells","_regions","invariant","first","last","isSpacer","cells","_findRegion","firstIntersect","firstIntersectIdx","lastIntersect","lastIntersectIdx","newLeadRegion","newTailRegion","newMainRegion","push","replacementRegions","numRegionsToDelete","splice","other","length","every","region","i","cellIdx","firstIdx","lastIdx","middleIdx","Math","floor","middleRegion"],"sources":["CellRenderMask.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport invariant from 'invariant';\n\nexport type CellRegion = {\n  first: number,\n  last: number,\n  isSpacer: boolean,\n};\n\nexport class CellRenderMask {\n  _numCells: number;\n  _regions: Array<CellRegion>;\n\n  constructor(numCells: number) {\n    invariant(\n      numCells >= 0,\n      'CellRenderMask must contain a non-negative number os cells',\n    );\n\n    this._numCells = numCells;\n\n    if (numCells === 0) {\n      this._regions = [];\n    } else {\n      this._regions = [\n        {\n          first: 0,\n          last: numCells - 1,\n          isSpacer: true,\n        },\n      ];\n    }\n  }\n\n  enumerateRegions(): $ReadOnlyArray<CellRegion> {\n    return this._regions;\n  }\n\n  addCells(cells: {first: number, last: number}): void {\n    invariant(\n      cells.first >= 0 &&\n        cells.first < this._numCells &&\n        cells.last >= -1 &&\n        cells.last < this._numCells &&\n        cells.last >= cells.first - 1,\n      'CellRenderMask.addCells called with invalid cell range',\n    );\n\n    // VirtualizedList uses inclusive ranges, where zero-count states are\n    // possible. E.g. [0, -1] for no cells, starting at 0.\n    if (cells.last < cells.first) {\n      return;\n    }\n\n    const [firstIntersect, firstIntersectIdx] = this._findRegion(cells.first);\n    const [lastIntersect, lastIntersectIdx] = this._findRegion(cells.last);\n\n    // Fast-path if the cells to add are already all present in the mask. We\n    // will otherwise need to do some mutation.\n    if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {\n      return;\n    }\n\n    // We need to replace the existing covered regions with 1-3 new regions\n    // depending whether we need to split spacers out of overlapping regions.\n    const newLeadRegion: Array<CellRegion> = [];\n    const newTailRegion: Array<CellRegion> = [];\n    const newMainRegion: CellRegion = {\n      ...cells,\n      isSpacer: false,\n    };\n\n    if (firstIntersect.first < newMainRegion.first) {\n      if (firstIntersect.isSpacer) {\n        newLeadRegion.push({\n          first: firstIntersect.first,\n          last: newMainRegion.first - 1,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.first = firstIntersect.first;\n      }\n    }\n\n    if (lastIntersect.last > newMainRegion.last) {\n      if (lastIntersect.isSpacer) {\n        newTailRegion.push({\n          first: newMainRegion.last + 1,\n          last: lastIntersect.last,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.last = lastIntersect.last;\n      }\n    }\n\n    const replacementRegions: Array<CellRegion> = [\n      ...newLeadRegion,\n      newMainRegion,\n      ...newTailRegion,\n    ];\n    const numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;\n    this._regions.splice(\n      firstIntersectIdx,\n      numRegionsToDelete,\n      ...replacementRegions,\n    );\n  }\n\n  numCells(): number {\n    return this._numCells;\n  }\n\n  equals(other: CellRenderMask): boolean {\n    return (\n      this._numCells === other._numCells &&\n      this._regions.length === other._regions.length &&\n      this._regions.every(\n        (region, i) =>\n          region.first === other._regions[i].first &&\n          region.last === other._regions[i].last &&\n          region.isSpacer === other._regions[i].isSpacer,\n      )\n    );\n  }\n\n  _findRegion(cellIdx: number): [CellRegion, number] {\n    let firstIdx = 0;\n    let lastIdx = this._regions.length - 1;\n\n    while (firstIdx <= lastIdx) {\n      const middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n      const middleRegion = this._regions[middleIdx];\n\n      if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {\n        return [middleRegion, middleIdx];\n      } else if (cellIdx < middleRegion.first) {\n        lastIdx = middleIdx - 1;\n      } else if (cellIdx > middleRegion.last) {\n        firstIdx = middleIdx + 1;\n      }\n    }\n\n    invariant(false, `A region was not found containing cellIdx ${cellIdx}`);\n  }\n}\n"],"mappings":"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"}